<META HTTP-EQUIV="expires" CONTENT="0">
<html>
<A name = "top"></A>
<title> CS255 Syllabus </title>
<body
text = "#000000"
link="#00ff00"
vlink="#f00000"
bgcolor="#ffffff"
>

<H3>
<HR>
First Recursive Function: Factorial
<HR>
</H3>

<UL>
<P>
<LI> <FONT COLOR="darkmagenta"><B>
     1st recursion example: Factorial
     </B></FONT>

 <UL>
<P>
 <LI> The factorial function can be written in a
  <FONT color="red"><B>high level programming language</B></FONT>
          as follows:
<P>
<UL>
<TABLE bgcolor="lightcyan" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
 int fac(int n)
 {
    if (n == 0)
       return(1);                   <--- easy case
    else
    {
       return( n * <FONT color="red">fac(n-1)</FONT> );      <--- Return the solution for fac(n)      
    }
 }

 main( )
 {
    int result, k;

    result = <FONT color="red">fac(k)</FONT>;
 }
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
<FONT color="red"><B>Notice that:</B></FONT>
<P>
<UL>
<TABLE bgcolor="#FFEEEE" BORDER="5">
<TR> <TD>

 <UL>
 <LI> <FONT color="red"><B><TT>main( )</TT></B></FONT> calls the
       <FONT color="blue"><B><TT>fac( )</TT></B></FONT> method
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

 <UL>
 <LI> <FONT color="red"><B><TT>main( )</TT></B></FONT> must
      pass the <FONT color="blue"><B>parameter</B></FONT> using the
      <FONT color="red"><B>program stack</B></FONT> !!!
 </UL>

</TD> </TR>
</TABLE>
</UL>
<P>
<HR>
<P>
 <LI> <FONT color="red"><B><TT>fac( )</TT></B></FONT> <B>also</B>
       calls the
       <FONT color="blue"><B><TT>fac( )</TT></B></FONT> method
       (see: <FONT color="red"><B><TT>fac(n-1)</TT></B></FONT>)
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

 <UL>
 <LI> When <FONT color="red"><B><TT>fac(n)</TT></B></FONT>
     calls <FONT color="blue"><B><TT>fac(n-1)</TT></B></FONT>,
      <FONT color="red"><B>fac(n)</TT></B></FONT> must
      pass the <FONT color="blue"><B>parameter (n-1)</B></FONT> using the
      <FONT color="red"><B>program stack</B></FONT> !!!
 </UL>

</TD> </TR>
</TABLE>
</UL>
<P>
 </UL>

</TD> </TR>
</TABLE>
</UL>
<P>
</UL>
<P>
<HR>
<HR>
<HR>
<HR>
<P>
<LI> <FONT COLOR="darkmagenta"><B>
     Calling the factorial method
     </B></FONT>
<P>
<UL>
<LI> From the fact that 
     you must <FONT color="red"><B>pass parameters</B></FONT> of
     a <FONT color="blue"><B>recursive method</B></FONT> using the
     <FONT color="red"><B>program stack</B></FONT>
     and the fact that
     <FONT color="blue"><B><TT>fac( )</TT></B></FONT> has
     a <FONT color="red"><B>parameter <TT>n</TT></B></FONT>, 
     this is <FONT color="blue"><B>how</B></FONT> the
    <B><TT>main( )</TT></B> function must
     call <FONT color="red"><B><TT>fac(k)</TT></B></FONT>:
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
     push  parameter (k) on the stack

     bl    fac

     add   sp, sp, #4           // Clean up the parameter (n) from the stack   
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

</UL>


<P>
<P>
<HR>
<HR>
<HR>
<HR>
<P>
<LI> <FONT COLOR="darkmagenta"><B>
    The stack frame structure for the factorial function
     </B></FONT>
<P>
<UL>

 <LI> The <FONT color="blue"><B>stack frame structure</B></FONT>
      that you need to 
    <B>create</B> will
     <FONT color="red"><B>depend</B></FONT>
      on:
<P>
<UL>
<TABLE bgcolor="#FFEEEE" BORDER="5">
<TR> <TD>

 <UL>
 <LI>  The <FONT color="red"><B>number</B></FONT> of
      <FONT color="blue"><B> parameters</B></FONT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>and</B>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <LI>  The <FONT color="red"><B>number</B></FONT>
    of <FONT color="blue"><B>local variables</B></FONT> used in the function.
 </UL>

</TD> </TR>
</TABLE>
</UL>
<P>

 <P>
 <LI> In the <FONT color="red"><B><TT>fac( )</TT></B></FONT> method
      above, we see that:
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

 <UL>
 <LI> The <FONT color="blue"><B> factorial function</B></FONT> has
     <FONT color="red"><B>1 parameter variable</B></FONT>
	and 
 <LI> <FONT color="red"><B>0 local variables</B></FONT>.
 </UL>

</TD> </TR>
</TABLE>
</UL>
<P>
 <HR>
 <P>
 <LI> The <FONT color="red"><B>stack frame structure</B></FONT>
     created (and used by <FONT color="blue"><B><TT>fac( )</TT></B></FONT>
     will <FONT color="red"><B>therefore</B></FONT>
     be as follows:

<P>
<UL>
<TABLE bgcolor="lightcyan" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
 <FONT color="red">Stack frame</FONT> of the <FONT color="red">fac( )</FONT> method:

    SP
    FP -----> +---------------------+                  
              |  old Frame Pointer  |
              +---------------------+
              |  Return Address     |
              +---------------------+
              |  Parameter n        |  <FONT color="red">addr(n) = FP + 8</FONT>        
              +---------------------+

</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
You can see that the
 <FONT color="red"><B><TT>fac( )</TT></B></FONT> function will
 <FONT color="blue"><B>access</B></FONT> the
 <FONT color="red"><B>parameter variable (<TT>n</TT>)</B></FONT> using
  <FONT color="blue"><B>offset 8</B></FONT> from the
 <FONT color="red"><B>frame pointer FP</B></FONT>
<P>
 </UL>
<P>
<P>
<HR>
<HR>
<HR>
<HR>
<P>
<LI> <FONT COLOR="darkmagenta"><B>
     The <TT>main( )</TT> call to factorial
     </B></FONT>
<P>
<UL>
<LI> Here is the <FONT color="red"><B>assembler code</B></FONT>
    for the <FONT color="blue"><B><TT>main( )</TT></B></FONT> function
    that calls <FONT color="red"><B><TT>fac( )</TT></B></FONT> with
    the <FONT color="blue"><B>value in the variable <TT>k</TT></B></FONT>:
<P>
<UL>
<TABLE bgcolor="#FFEEEE" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
main:
<FONT color="darkgreen">
        //  High level programming statement:
	//
	//     result = fac(k)</FONT>
<FONT color="red">
        /* -------------------------------------------------
           Pass parameter k (using stack)
           ------------------------------------------------- */</FONT>
        movw    r0, #:lower16:k
        movt    r0, #:upper16:k
        ldr     r0, [r0]            // r0 = k
        push    {r0}                // Pass k using the program stack
<FONT color="red">
        /* ------------------------------------------------------
           call fac(k)
           ------------------------------------------------------ */</FONT>
        bl      fac

        add     sp, sp, #4      <FONT color="red">// Clean up the parameter k</FONT>
<FONT color="red">
        /* -----------------------------------------------------------------
           Assign return value (in r0) to variable result
           ----------------------------------------------------------------- */</FONT>
        movw    r1, #:lower16:result  // Do NOT use r0 !!!
        movt    r1, #:upper16:result  // (Because <FONT color="red">r0 contains the return value</FONT>)

        str     r0, [r1]             // This will store return value in result
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

</UL>

<P>
<HR>
<HR>
<HR>
<HR>
<P>
<LI> <FONT COLOR="darkmagenta"><B>
     The factorial recursive method/function
     </B></FONT>
<P>
<UL>
<P>
<LI> The <FONT color="red"><B>factorial method</B></FONT> in
   <FONT color="blue"><B>assembler</B></FONT>:
<P>
<UL>
<TABLE bgcolor="lightcyan" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
/* ----------------------------------------------------------------
   Function int fac(int n)

        <FONT color="red">Stack frame</FONT> structure:
<FONT color="red">
                old FP   <--------------------------------- FP
                old LR (ret addr)
                  n                     +8</FONT>
<FONT color="darkred">
   Body of fac(n)</FONT>

        if ( n == 0 )
           return 1;
        else
           return n*fac(n-1);
   ---------------------------------------------------------------- */
<FONT color="red">
fac:</FONT>

        // When  fac  begins, we will have: parameter  n  on the stack

<FONT color="red">
        /* ==========================================================
           Function Prelude: complete the stack frame structure
           ========================================================== */</FONT>
        <FONT color="darkgreen">push    {lr}            // Save LR (return address)
        push    {fp}            // Save FP (used by caller)
        mov     fp, sp          // Mark the stack top location before
                                // allocating any local variables
        sub     sp, sp, #0      // Allocate 0 int variables on the stack
                                <FONT color="red">// (I could omit this instruction....)</FONT></FONT>

<FONT color="red">
        /* ===============================================
           We have completed the stack frame
           Now we can write the function body
           =============================================== */</FONT>
        // if ( n == 0 )
        ldr     r0, [fp, #8]    // r0 = n

        cmp     r0, #0          // Check n == 0
        bne     else            // n != 0 --> Goto "else" part
<FONT color="red">
        // return 1</FONT>

        ///// put return value 1 in return location r0
        mov     r0, #1
<FONT color="red">
        /* =============================================================
           Function Postlude: de-allocate local variable and restore FP
           ============================================================= */</FONT>
        <FONT color="darkgreen">mov     sp, fp          // De-allocate local variables
        pop     {fp}            // Restore fp
        pop     {pc}            // Return to the caller</FONT>


else:
        <FONT color="red">// Compute: n*fac(n-1)</FONT>

        //// Compute fac(n-1) first
        ldr     r0, [fp, #8]    // r0 = n
        sub     r0, r0, #1      // r0 = n-1

        push    {r0}            // pass (n-1) to fac on stack
        <FONT color="red">bl      fac             // Calls:  fac( ) with parameter = (n-1) !!!</FONT>                
        add     sp, sp, #4      // Clean up parameter (n-1) from stack

        //// ** Right now, r0 = fac(n-1) !!!

        //// Compute n*fac(n-1) next
        ldr     r1, [fp, #8]    // r0 = n
        mul     r0, r1, r0      // <FONT color="red">r0 = n*fac(n-1)</FONT>
                                // NOTE: r0 has the correct return value !!!

        // return   n*fac(n-1)  in r0
        <FONT color="red">/* =============================================================
           Function Postlude: de-allocate local variable and restore FP
           ============================================================= */</FONT>
        <FONT color="darkgreen">mov     sp, fp          // De-allocate local variables
        pop     {fp}            // Restore fp
        pop     {pc}            // Return to the caller</FONT>
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
 <P>
 <HR>
 <P>
 <LI> <FONT color="#00a000"><B> Example Program: </B></font>
      (Demo above code)
      &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
      &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
      <SUB><SUB><SUB>
        <IMG SRC="../../../Common/Example.jpg"></IMG>
        </SUB></SUB></SUB>
  <P>
  <UL>
  <LI> Prog file:
       <FONT COLOR="red"><B><TT>
       /home/cs255001/demo/asm/8-sub/fac.s
       </TT></B></FONT>
  </UL>
<P>
 <B>How to run the program:</B>
<P>
<UL>
<TABLE bgcolor="#CCFFCC" BORDER="5">
<TR> <TD>

 <UL>
 <LI> To compile: 
  &nbsp; <FONT color="red"><B><TT>as255 fac</TT></B></FONT>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <LI> To run: 
	use
  <FONT color="red"><B><TT>EGTAPI</TT></B></FONT>
 </UL>

</TD> </TR>
</TABLE>
</UL>
<P>
<HR>
<HR>
<P>
  <LI> I will highlight certain steps in the  program in the
	remainder of the webpage....
  </UL>
<P>

<HR>
<HR>
<HR>
<HR>
<P>
<LI> <FONT COLOR="darkmagenta"><B>
     Highlights important steps in the <TT>fac</TT> function
     </B></FONT>
<P>
<UL>

<LI> <FONT color="blue"><B>Passing the
      parameter <FONT color="red"><B><TT>k</TT></B></FONT>
     from main program to fac</B></FONT>
 <P>
 The main program passes the variable 
  <FONT color="red"><B><TT>k</TT></B></FONT>
      to the factorial method by pushing
	the value
  of variable <FONT color="red"><B><TT>k</TT></B></FONT>
    onto the system stack with the following instruction:
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
        movw    r0, #:lower16:k
        movt    r0, #:upper16:k
        ldr     r0, [r0]            // Now: r0 = k

        push    {r0}                // Pass k using the program stack      
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

 This will create the following stack structure:
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
   +---------------------+ <------------ Stack pointer (SP)      
   |  k = parameter n    |
   +---------------------+
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>



<HR>



<P>
<LI> <FONT color="blue"><B>Main program calling the
    <FONT color="red"><B><TT> fac</TT></B></FONT> function</B></FONT>
 <P>
 The main program calls the factorial function with a 
   <FONT color="red"><B><TT>bl</TT></B></FONT> instruction:
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
        bl      fac                       
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

 This will <FONT color="red"><B>save</B></FONT> the
  <FONT color="blue"><B>return address to <TT>main( )</TT></B></FONT>
  in the <FONT color="red"><B><TT>LR register</TT></B></FONT>
  and <FONT color="blue"><B>jump to the <TT>fac</TT> method</B></FONT>
<P>
<SPAN style="BACKGROUND-COLOR: yellow">
The <FONT color="red"><B><TT>fac( )</TT></B></FONT> function will
  <FONT color="blue"><B>start running</B></FONT>, so
 let's take a look at the
  <FONT color="red"><B><TT>fac( )</TT></B></FONT> function
</SPAN>
<P>
<HR>
<HR>
<HR>
<P>
<LI> <FONT color="blue"><B>Prelude of the Factorial function:</B></FONT>
  <P>
  The prelude of the factorial function consists of these instructions:
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
        <FONT color="red">/* ==========================================================
           Function Prelude: complete the stack frame structure
           ========================================================== */</FONT>
        <FONT color="darkgreen">push    {lr}            // Save LR (return address)
        push    {fp}            // Save FP (used by caller)
        mov     fp, sp          // Mark the stack top location before
                                // allocating any local variables
        sub     sp, sp, #0      // Allocate 0 int variables on the stack            
                                <FONT color="red">// (I could omit this instruction....)</FONT></FONT>
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

  I will explain what each one does below.
<P>
  Make sure that you realise that the structure of the stack frame is
   like this when the prelude of the
  <FONT color="red"><B><TT>fac( )</TT></B></FONT> method is executed:
<P>
<UL>
<TABLE bgcolor="#FFEEEE" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
   +---------------------+ <------------ Stack pointer (SP)         
   |     parameter n     |
   +---------------------+
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

  <UL>
  <LI> <FONT color="red"><B><TT>push&nbsp;{lr}</TT></B></FONT>
 <P>
   This <B>instruction</B> will
   save the <B>return address </B> in the
   <FONT color="red"><B><TT>LR</TT></B></FONT> register on the 
   <B>program stack</B>.
 <P>
   The <B>program stack</B> now looks like this:
<P>
<UL>
<TABLE bgcolor="#FFEEEE" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
   +---------------------+ <------------ Stack pointer (SP)         
   |  return address     |
   +---------------------+
   |     parameter n     |
   +---------------------+
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
<LI> <FONT color="red"><B><TT>push&nbsp;{fp}</TT></B></FONT>


   <P>
   This will save the <B>frame pointer</B> on the stack and
       the <B>program stack</B> now looks like this:
<P>
<UL>
<TABLE bgcolor="#FFEEEE" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
   +---------------------+ <------------ Stack pointer (SP)         
   |  old Frame Pointer  |
   +---------------------+
   |  return address     |
   +---------------------+
   |     parameter n     |
   +---------------------+
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>


  <LI> <FONT color="red"><B><TT>mov&nbsp;fp,sp</TT></B></FONT>
   <P>
   This will make the <B>frame pointer</B>
   <FONT color="red"><B><TT>FP</TT></B></FONT>
      points to the stack frame that
	is  being built:
<P>
<UL>
<TABLE bgcolor="#FFEEEE" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
   +---------------------+ <------------ Frame pointer FP & Stack pointer SP  
   |  old Frame Pointer  |               point to the same location....
   +---------------------+
   |  return address     |
   +---------------------+
   |     parameter n     |
   +---------------------+
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
The will <FONT color="red"><B>enable</B></FONT>
 the <FONT color="blue"><B><TT>fac( )</TT></B></FONT> to use
 <FONT color="red"><B>offset</B></FONT> from
  the <B>frame pointer</B></FONT> to
  access the <FONT color="blue"><B>parameters </B></FONT> and
  <FONT color="blue"><B>local variables</B></FONT>
  that are <B>stored</B> in the <FONT color="red"><B>program stack</B></FONT>
<P>

  <LI> <FONT color="red"><B><TT>sub&nbsp;sp,sp,#0</TT></B></FONT>
   <P>
    The <FONT color="red"><B>subtract</B></FONT> instruction
    is used to <FONT color="blue"><B>allocate local variables</B></FONT>
    on the <FONT color="red"><B>program stack</B></FONT>
 <P>
   But since <FONT color="red"><B><TT>fac( )</TT></B></FONT> has
   <FONT color="blue"><B>no local variables</B></FONT>,
   this instruction does nothing to the stack pointer 
   <FONT color="red"><B><TT>SP</TT></B></FONT>... (and we could omit it -
   I left it in to keep the discussion 
  <FONT color="blue"><B>uniform</B></FONT>)
<P>
 We have now <FONT color="red"><B>completed</B></FONT> the
   <FONT color="blue"><B>stack frame</B></FONT>:
<P>
<UL>
<TABLE bgcolor="lightCYAN" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
   +---------------------+ <---- Frame pointer FP & Stack pointer SP     
   |  old Frame Pointer  |       point to the same location....
   +---------------------+
   |     return address  |
   +---------------------+
   |     parameter n     |
   +---------------------+
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
 When the prelude is finish, the stack frame is complete and
	the actual function can begin.
 </UL>
<P>
<HR>
<P>
<LI> <FONT color="blue"><B>How to access the parameter
  <FONT color="red"><B><TT>n</TT></B></FONT> in the
    <FONT color="red"><B><TT>fac</TT></B></FONT> function:</B></FONT>
 <P>
 <UL>
 <LI> Parameter <FONT color="red"><B><TT>n</TT></B></FONT>
        is located <FONT color="blue"><B>8 bytes</B></FONT>
       (<B>old Frame Pointer</B> is 4 bytes and
       <B>return address</B> is 4 bytes)
         <FONT color="red"> <B>below</B></FONT>
       the location <FONT color="blue"><B>pointed to</B></FONT>
       by frame pointer <FONT color="red"><B><TT>FP</TT></B></FONT>:
<P>
<UL>
<TABLE bgcolor="#FFEEEE" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
   +---------------------+ <-------------- Frame pointer FP 
   |  old Frame Pointer  |  (4 bytes)     
   +---------------------+
   |     return address  |  (4 bytes)
   +---------------------+
   |     parameter n     | <--- offset = 8
   +---------------------+
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

    <P>
     So the <FONT color="red"><B>base register (FP)</TT></B></FONT>
      + <FONT color="blue"><B>offset 8</B></FONT>
         will let you access this variable
 <P>
 That's why you see the use of the instruction&nbsp;
  <FONT color="red"><B><TT>ldr&nbsp;r1,&nbsp;[fp,#8]</TT></B></FONT>
    in
  <FONT color="red"><B><TT>fac( )</TT></B></FONT> to get
  the parameter:
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
        ldr     r1, <FONT color="red">[fp, #8]</FONT>    // r0 = n          
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

  </UL>
<P>
<HR>
<P>
<LI> <FONT color="blue"><B>How <FONT color="red"><B><TT>fac(n)</TT></B></FONT>
      calls <FONT color="red"><B><TT>fac(n-1)</TT></B></FONT>:</B></FONT>
  <P>
  It is no different from how the main program calls the factorial function.
<P>
  The <B>factorial</B> method can call
   the <B>factorial </B> method by
   <FONT color="red"><B>passing</B></FONT> the
   <FONT color="blue"><B>parameter</B></FONT> on the
   <B>program stack</B> and then
   use <FONT color="red"><B><TT>bl&nbsp;fac</TT></B></FONT> to
   call the <B>factorial </B> method.
<P>

  But <B>make sure</B> you <B>pop the parameter</B> from the stack
 <FONT color="red"><B> after</B></FONT> the
	factorial function returns - because the parameter
   has not been cleaned up.
  <P>
  The following is the program fragment where factorial calls 
  <FONT color="red"><B><TT>fac(n-1)</TT></B></FONT>:
<P>
<UL>
<TABLE bgcolor="#CCFFCC" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
        ldr     r0, [fp, #8]    // r0 = n
        sub     r0, r0, #1      // r0 = <FONT color="red">n-1</FONT>

        push    {r0}            // pass (n-1) to fac on stack

        <FONT color="red">bl      fac             // Calls:  fac( ) with parameter = (n-1) !!!</FONT>       
         
        add     sp, sp, #4      // Clean up parameter (n-1) from stack
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
</UL>
</UL>
<HR>
<HR>
<HR>
<HR>
