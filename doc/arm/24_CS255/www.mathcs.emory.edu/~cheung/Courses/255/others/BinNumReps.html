<HTML><HEAD><TITLE>Binary Number Representations</TITLE></HEAD><BODY><h1>Unsigned Binary Integer</h1><B>BITS</B> <P>High order bit is leftmost, low order (least significant) bit is rightmost.  The location of each bitdetermines its value:<blockquote><code>     33222222222211111111110000000000<BR>     10987654321098765432109876543210<BR>     BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB<br>     |&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br></code>     2<sup>31</sup> place&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<sup>10</sup>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<sup>0</sup> </blockquote><B>EXAMPLE</B> <P>What is the 32-bit unsigned binary integer representation for the decimal integer 86420?<BR><P><B>SOLUTION</B><P>1.Succesively divide by 2 until the result is zero.  The remainders of these divisions will be the bitsused to construct the solution.<code><blockquote>     86420 &#247; 2 = 43210     rem 0    &nbsp;&nbsp;&nbsp;&nbsp;Low order bit<BR>     43210 &#247; 2 = 21605     rem 0 <BR>     21605 &#247; 2 = 10802     rem 1 <BR>     10802 &#247; 2 =  &nbsp;5401     rem 0<BR>      &nbsp;5401 &#247; 2 =  &nbsp;2700     rem 1<BR>       &nbsp;2700 &#247; 2 =  &nbsp;1350     rem 0<BR>       &nbsp;1350 &#247; 2 =   &nbsp;&nbsp;675     rem 0<BR>        &nbsp; 675 &#247; 2 =   &nbsp;&nbsp;337     rem 1<BR>        &nbsp; 337 &#247; 2 =   &nbsp;&nbsp;168     rem 1<BR>          &nbsp; 168 &#247; 2 =    &nbsp;&nbsp;&nbsp;84     rem 0<BR>         &nbsp; &nbsp;84 &#247; 2 =    &nbsp;&nbsp;&nbsp;42     rem 0<BR>         &nbsp; &nbsp;42 &#247; 2 =    &nbsp;&nbsp;&nbsp;21     rem 0<BR>        &nbsp; &nbsp;21 &#247; 2 =    &nbsp;&nbsp;&nbsp;10     rem 1<BR>         &nbsp; &nbsp;10 &#247; 2 =     &nbsp;&nbsp;&nbsp;&nbsp;5     rem 0<BR>          &nbsp; &nbsp; 5 &#247; 2 =     &nbsp;&nbsp;&nbsp;&nbsp;2     rem 1<BR>          &nbsp; &nbsp; 2 &#247; 2 =     &nbsp;&nbsp;&nbsp;&nbsp;1     rem 0<BR>          &nbsp; &nbsp; 1 &#247; 2 =     &nbsp;&nbsp;&nbsp;&nbsp;0     rem 1    &nbsp;&nbsp;&nbsp;&nbsp;High order bit<BR></blockquote></code>2.  Organize the remainder bits into the binary integer:<blockquote>     10101000110010100</blockquote>3.  Pad the bits to the left with zeroes to bring to a total of 32:<blockquote>     000000000000000 10101000110010100</blockquote>4. Convert to hex:<blockquote>     0000 0000 0000 0001 0101 0001 1001 0100<P>     00015194</blockquote><BR><HR ALIGN=center WIDTH=100% SIZE=2><br><h1>Sign-Magnitude Signed Binary Integer</h1><B>BITS</B> <code><blockquote>     33222222222211111111110000000000<BR>     10987654321098765432109876543210<BR>     SBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</blockquote></code>where <blockquote>     S = 1 for negative number, 0 for non-negative</blockquote>The remaining bits in position n represents 2<sup>n</sup> place.<B><BR><BR>EXAMPLE</B> <P>What is the 32-bit sign-magnitude binary integer representation for the decimal integer -47?<P><BR><B>SOLUTION</B><P>1.  S = 1, for negative number.  <BR><BR>2.  Solve as for an unsigned integer for the remaining 31 bits.<blockquote>      47<sub>10</sub> = 101111<sub>2</sub></blockquote>3.  Organize the bits, padding with zeroes between the sign and the magnitude:<blockquote>     1 0000000000000000000000000 101111</blockquote><br>4.  Convert to hex:<blockquote>     1000 0000 0000 0000 0000 0000 0010 1111<P>     8000002F</blockquote><BR><HR ALIGN=center WIDTH=100% SIZE=2><br><h1>2's-Complement Signed Binary Integer</h1><B>BITS</B> <code><blockquote><BR>     33222222222211111111110000000000<BR>     10987654321098765432109876543210<BR>     SBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB<P></blockquote></code><BR>where <blockquote>     S = 0 for non-negative numbers<P> <blockquote>         Interpretation:<P><blockquote>               the remaining 31 bits represent the magnitude of the non-negative number.</blockquote></blockquote> </blockquote> <blockquote>    S = 1 for negative numbers<P> <blockquote>         Interpretation:<P>  <blockquote>             Invert all the bits 2's-complement number.<BR>              Add 1.<BR>               The resulting 32 bits represent the magnitude of the negative number.<BR><br>Note: this is the same as subtracting 1 from the 2's-complement number and then inverting the bits.  <a href="binNumFact.html">Click here</a> for more background.</blockquote></blockquote> </blockquote> <B><P>EXAMPLE 1</B> <P>What is the 32-bit 2's-complement signed binary integer representation for the decimal integer -47?<P><BR><B>SOLUTION</B><P>1.  Solve as for an unsigned integer for the magnitude:<blockquote>      47<sub>10</sub> = 101111<sub>2</sub></blockquote>2.  Pad with zeroes to form a 32-bit number: <blockquote>     00000000000000000000000000 101111</blockquote>3.  If the value was non-negative, the answer is now complete.  <P>4.  For a negative number we must next invert all the bits:<blockquote>     11111111111111111111111111010000</blockquote>5.  Add one to the result:<blockquote>     11111111111111111111111111010001</blockquote>6.  Convert to hex:<blockquote>     1111 1111 1111 1111 1111 1111 1101 0001<P>     FFFFFFD1</blockquote><BR><P><B>EXAMPLE 2</B> <P>What is the value of the 2's-complement number represented by the hexadecimal number FFFFFF99?<P><BR><B>SOLUTION</B><P>1.  Write out the bits:<blockquote>      1111 1111 1111 1111 1111 1111 1001 1001</blockquote>2.  Since the first bit is a 1 this is a negative number.  We must continue.  Invert all the bits.<blockquote>     0000 0000 0000 0000 0000 0000 0110 0110</blockquote>3.  Add 1.<P><blockquote>     0000 0000 0000 0000 0000 0000 0110 0111</blockquote>4.  Convert this result to decimal:<blockquote>     1100111<sub>2</sub> = 103<sub>10</sub> </blockquote>5.  Since the value is negative, the original binary number was the 2's-complement representation of the decimal number -103.<p><BR><B>BINARY ADDITION OF 2'S-COMPLEMENT NUMBERS<BR></B><BR>Binary addition of a 2's-complement signed integer is very simple. The rules are the same asdecimal addition, except that the carry of 1 happens when 1 is added to 1.  That is:<code><blockquote>     0 + 0 = 0<BR>     1 + 0 = 1<BR>     0 + 1 = 1<BR>     1 + 1 = 0, carry the 1</blockquote></code>A carry from the most significant bit position is discarded.  The carry out from the most significantbit must be the same as the carry in to that bit (either both 0 or both 1), otherwise an overflow orunderflow error has occurred.<BR> <BR>For example, using 4-bit 2's-complement signed binary integers:<code><blockquote>&nbsp;&nbsp;0 0 1 1     &nbsp;note: 0011<sub>2</sub> = 3<sub>10</sub><BR>+ 0 0 1 1      &nbsp;= &nbsp;3<br>---------<br>&nbsp;&nbsp;0 1 1 0      &nbsp;= &nbsp;6; carry in = carry out of sign bit = 0<P>&nbsp;&nbsp;1 0 0 1      &nbsp;= -7<BR>+ 0 0 1 1      &nbsp;= &nbsp;3<br>---------<br>&nbsp;&nbsp;1 1 0 0     &nbsp;=  -4; carry in = carry out = 0<P>&nbsp;&nbsp;1 0 0 1      &nbsp;= -7<BR>+ 1 0 0 1      &nbsp;= -7<br>---------<br>&nbsp;&nbsp;0 0 1 0      &nbsp;= ERROR; 1 = carry out bit; 0 = carry in to sign bit<BR><P>&nbsp;&nbsp;0 1 1 1      &nbsp;= &nbsp;7<BR>+ 0 1 1 1      &nbsp;= &nbsp;7<br>---------<br>&nbsp;&nbsp;1 1 1 0      &nbsp;= ERROR, 0 = carry out; 1 = carry in<BR><p>&nbsp;&nbsp;1 1 0 1      &nbsp;= -3<BR>+ 1 1 0 1     &nbsp;= -3<br>---------<br>&nbsp;&nbsp;1 0 1 0      &nbsp;= -6; carry out = carry in = 1; carry out bit is discarded.<P>&nbsp;&nbsp;1 1 0 1      &nbsp;= -3<BR>+ 0 0 1 1      &nbsp;= &nbsp;3<br>---------<br>&nbsp;&nbsp;0 0 0 0      &nbsp;= 0; carry out = carry in = 1; carry out bit is discarded.</blockquote></code><br><br><HR ALIGN=center WIDTH=100% SIZE=2><br><h1>IEEE 32-Bit Floating Point Format</h1><b>BITS</B><blockquote><code>33222222222211111111110000000000<BR>10987654321098765432109876543210<BR>SEEEEEEEEFFFFFFFFFFFFFFFFFFFFFFF<P></code>     =  (-1)<sup>s</sup>2<sup>e-127</sup>1.f</blockquote>where <blockquote>     s = S<BR>           e = EEEEEEEE, e > 0, e < 255<BR>           f = FFFFFFFFFFFFFFFFFFFFFFF<P></blockquote>Denormals: e = 0; Specials: (NaN, Inf, -Inf) e = 255 <P><B><BR>EXAMPLE</B> <P>What is the IEEE 32-bit floating point representation for the decimal number -11.5?<P><BR><B>SOLUTION</B><P>1. Convert to binary.  To the left of the binary point, represent the magnitude of the number to theleft of the decimal point.  To the right of the binary point, represent the fraction to the right of thedecimal point (note: this may require a loss of accuracy).  The first position after the binary point isthe 2<sup>-1</sup> position (0.5 decimal), then 2<sup>-2</sup> (0.25), 2<sup>-3</sup> (0.125), <I>etc</I>.<blockquote>-11.5<sub>10</sub> = -1011.1<sub>2</sub></blockquote>2. Convert to normalized binary scientific notation (<I>i.e.</I> move binary point to the left or right as farnecessary until a single one is to left of the binary point, <I>e.g.</I> 1.f):<blockquote>     -1011.1<sub>2</sub> = -1.0111 x 2<sup>3</sup><BR></blockquote>Note: in the special case of 0.0, all 32 bits are 0.  This is a denormal since there is no 1 to the leftof the binary point.<P>3. Determine s, e and f:       <blockquote>     s = 1 for negative, 0 for positive.<BR><br>     true exponent = 3<sub>10</sub> = e - 127, thus<BR>     e = 3 + 127 = 130<sub>10</sub> = 10000010<sub>2</sub><BR><br>     1.f = 1.0111, thus f = 0111    <BR>         </blockquote></code>4. Assemble the 32 bits, padding f to the right with zeroes:<code><blockquote>     s    &nbsp;&nbsp;e   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.fffffffffffffffffffffff <BR>     1     &nbsp;&nbsp;10000010       &nbsp;&nbsp;&nbsp;01110000000000000000000<P>     11000001001110000000000000000000</blockquote></code>5. Convert to hex:<code><blockquote>     1100 0001 0011 1000 0000 0000 0000 0000<br><br>     C1380000 </blockquote></code>Note special cases: <br><br><blockquote>	s = 0, e=255, f = all zeroes: +Infinity<br>	s = 1, e=255, f = all zeroes: -Infinity<br>	s = 0 or 1, e=255, f = anything but all zeroes: Not A Number<BR></blockquote><BR></BODY></HTML>