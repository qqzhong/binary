; Listing generated by Microsoft (R) Optimizing Compiler Version 19.22.27905.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	NtCurrentTeb
PUBLIC	get_imp
PUBLIC	main
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_LoadLibraryA:PROC
EXTRN	printf:PROC
pdata	SEGMENT
$pdata$get_imp DD imagerel $LN9
	DD	imagerel $LN9+299
	DD	imagerel $unwind$get_imp
$pdata$main DD	imagerel $LN14
	DD	imagerel $LN14+670
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG94694 DB	'advapi32.dll', 00H
	ORG $+3
$SG94697 DB	'LoadLibraryA', 00H
	ORG $+3
$SG94698 DB	'GetProcAddress', 00H
	ORG $+1
$SG94699 DB	0aH, 'GetProcAddress : %p', 0aH, 'LoadLibraryA   : %p', 0aH
	DB	00H
	ORG $+6
$SG94700 DB	'LoadLibraryA', 00H
	ORG $+3
$SG94701 DB	'kernel32', 00H
	ORG $+7
$SG94702 DB	'GetProcAddress', 00H
	ORG $+1
$SG94703 DB	'kernel32', 00H
	ORG $+7
$SG94704 DB	0aH, 'GetProcAddress : %p', 0aH, 'LoadLibraryA   : %p', 0aH
	DB	00H
_DATA	ENDS
xdata	SEGMENT
$unwind$get_imp DD 011301H
	DD	06213H
$unwind$main DD	020701H
	DD	0150107H
xdata	ENDS
; Function compile flags: /Odsp
; File C:\hub\shellcode\os\win\getapi\extern\extern_llagpa.c
_TEXT	SEGMENT
hash$ = 32
i$ = 36
dte$ = 40
base$ = 48
imp$ = 56
rva$ = 64
gpa$ = 72
name$ = 80
lla$ = 88
peb$ = 96
ldr$ = 104
dll$ = 112
dos$ = 120
nt$ = 128
dir$ = 136
tv157 = 144
main	PROC

; 68   : int main(void) {

$LN14:
	sub	rsp, 168				; 000000a8H

; 69   :     DWORD                    rva, hash, i;
; 70   :     PIMAGE_IMPORT_DESCRIPTOR imp;
; 71   :     PIMAGE_DOS_HEADER        dos;
; 72   :     PDWORD                   name;
; 73   :     PIMAGE_THUNK_DATA        oft, ft;
; 74   :     PIMAGE_IMPORT_BY_NAME    ibn;  
; 75   :     PIMAGE_NT_HEADERS        nt;
; 76   :     PIMAGE_DATA_DIRECTORY    dir;
; 77   :     LPVOID                   base, lla=NULL, gpa=NULL;

	mov	QWORD PTR lla$[rsp], 0
	mov	QWORD PTR gpa$[rsp], 0

; 78   :     PWCHAR                   dll;
; 79   :     PPEB                     peb;
; 80   :     PPEB_LDR_DATA            ldr;
; 81   :     PLDR_DATA_TABLE_ENTRY    dte;
; 82   :     
; 83   :     LoadLibrary("advapi32.dll"); // only for testing

	lea	rcx, OFFSET FLAT:$SG94694
	call	QWORD PTR __imp_LoadLibraryA

; 84   :     
; 85   :     peb = (PPEB)NtCurrentTeb()->ProcessEnvironmentBlock;

	call	NtCurrentTeb
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR peb$[rsp], rax

; 86   :     ldr = (PPEB_LDR_DATA)peb->Ldr;

	mov	rax, QWORD PTR peb$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR ldr$[rsp], rax

; 87   :     
; 88   :     // for each DLL in PEB
; 89   :     for (dte=(PLDR_DATA_TABLE_ENTRY)ldr->InLoadOrderModuleList.Flink;

	mov	rax, QWORD PTR ldr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR dte$[rsp], rax
	jmp	SHORT $LN4@main
$LN2@main:

; 91   :          dte=(PLDR_DATA_TABLE_ENTRY)dte->InLoadOrderLinks.Flink)

	mov	rax, QWORD PTR dte$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR dte$[rsp], rax
$LN4@main:

; 90   :          dte->DllBase != NULL && gpa == NULL; 

	mov	rax, QWORD PTR dte$[rsp]
	cmp	QWORD PTR [rax+48], 0
	je	$LN3@main
	cmp	QWORD PTR gpa$[rsp], 0
	jne	$LN3@main

; 92   :     {
; 93   :       // hash the DLL name
; 94   :       dll = dte->BaseDllName.Buffer;

	mov	rax, QWORD PTR dte$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR dll$[rsp], rax

; 95   : 
; 96   :       for (hash=0, i=0; i<dte->BaseDllName.Length/2; i++) {

	mov	DWORD PTR hash$[rsp], 0
	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@main
$LN5@main:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@main:
	mov	rax, QWORD PTR dte$[rsp]
	movzx	eax, WORD PTR [rax+88]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN6@main

; 97   :         hash = ROTR32(hash, 13); 

	mov	eax, DWORD PTR hash$[rsp]
	shr	eax, 13
	mov	ecx, DWORD PTR hash$[rsp]
	shl	ecx, 19
	or	eax, ecx
	mov	DWORD PTR hash$[rsp], eax

; 98   :         hash += dll[i] | 0x20;  

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR dll$[rsp]
	movzx	eax, WORD PTR [rcx+rax*2]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR hash$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR hash$[rsp], eax

; 99   :       }

	jmp	SHORT $LN5@main
$LN6@main:

; 100  :       // is this the target DLL?
; 101  :       if (hash == DLL_HASH)

	cmp	DWORD PTR hash$[rsp], 1120728991	; 42ccf79fH
	jne	$LN11@main

; 102  :       {
; 103  :         base = dte->DllBase;

	mov	rax, QWORD PTR dte$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR base$[rsp], rax

; 104  :         dos  = (PIMAGE_DOS_HEADER)base;

	mov	rax, QWORD PTR base$[rsp]
	mov	QWORD PTR dos$[rsp], rax

; 105  :         nt   = RVA2VA(PIMAGE_NT_HEADERS, base, dos->e_lfanew);

	mov	rax, QWORD PTR dos$[rsp]
	movsxd	rax, DWORD PTR [rax+60]
	mov	rcx, QWORD PTR base$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR nt$[rsp], rax

; 106  :         dir  = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory;

	mov	rax, QWORD PTR nt$[rsp]
	add	rax, 136				; 00000088H
	mov	QWORD PTR dir$[rsp], rax

; 107  :         rva  = dir[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;  

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR dir$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR rva$[rsp], eax

; 108  :         imp  = (PIMAGE_IMPORT_DESCRIPTOR) RVA2VA(ULONG_PTR, base, rva);

	mov	eax, DWORD PTR rva$[rsp]
	mov	rcx, QWORD PTR base$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR imp$[rsp], rax

; 109  :       
; 110  :         // locate kernel32.dll descriptor
; 111  :         for (;imp->Name!=0;imp++) 

	jmp	SHORT $LN10@main
$LN8@main:
	mov	rax, QWORD PTR imp$[rsp]
	add	rax, 20
	mov	QWORD PTR imp$[rsp], rax
$LN10@main:
	mov	rax, QWORD PTR imp$[rsp]
	cmp	DWORD PTR [rax+12], 0
	je	$LN9@main

; 112  :         {
; 113  :           name = RVA2VA(PDWORD, base, imp->Name);

	mov	rax, QWORD PTR imp$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR base$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR name$[rsp], rax

; 114  :           
; 115  :           if ((name[0] | 0x20202020) == 'nrek' && 

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR name$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	or	eax, 538976288				; 20202020H
	cmp	eax, 1852990827				; 6e72656bH
	jne	SHORT $LN12@main
	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR name$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	or	eax, 538976288				; 20202020H
	cmp	eax, 842230885				; 32336c65H
	jne	SHORT $LN12@main

; 116  :               (name[1] | 0x20202020) == '23le')
; 117  :           {        
; 118  :             // locate GetProcAddress and LoadLibraryA
; 119  :             lla = get_imp(imp, base, (PDWORD)"LoadLibraryA");

	lea	r8, OFFSET FLAT:$SG94697
	mov	rdx, QWORD PTR base$[rsp]
	mov	rcx, QWORD PTR imp$[rsp]
	call	get_imp
	mov	QWORD PTR lla$[rsp], rax

; 120  :             gpa = get_imp(imp, base, (PDWORD)"GetProcAddress");

	lea	r8, OFFSET FLAT:$SG94698
	mov	rdx, QWORD PTR base$[rsp]
	mov	rcx, QWORD PTR imp$[rsp]
	call	get_imp
	mov	QWORD PTR gpa$[rsp], rax

; 121  :             break;

	jmp	SHORT $LN9@main
$LN12@main:

; 122  :           }
; 123  :         }

	jmp	$LN8@main
$LN9@main:
$LN11@main:

; 124  :       }
; 125  :     }    

	jmp	$LN2@main
$LN3@main:

; 126  :     printf ("\nGetProcAddress : %p"

	mov	r8, QWORD PTR lla$[rsp]
	mov	rdx, QWORD PTR gpa$[rsp]
	lea	rcx, OFFSET FLAT:$SG94699
	call	printf

; 127  :             "\nLoadLibraryA   : %p\n", gpa, lla);
; 128  :             
; 129  :     printf ("\nGetProcAddress : %p"

	lea	rcx, OFFSET FLAT:$SG94701
	call	QWORD PTR __imp_LoadLibraryA
	lea	rdx, OFFSET FLAT:$SG94700
	mov	rcx, rax
	call	QWORD PTR __imp_GetProcAddress
	mov	QWORD PTR tv157[rsp], rax
	lea	rcx, OFFSET FLAT:$SG94703
	call	QWORD PTR __imp_LoadLibraryA
	lea	rdx, OFFSET FLAT:$SG94702
	mov	rcx, rax
	call	QWORD PTR __imp_GetProcAddress
	mov	rcx, QWORD PTR tv157[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG94704
	call	printf

; 130  :             "\nLoadLibraryA   : %p\n", 
; 131  :             GetProcAddress(LoadLibraryA("kernel32"), 
; 132  :                 "GetProcAddress"), 
; 133  :                 
; 134  :             GetProcAddress(LoadLibraryA("kernel32"), 
; 135  :                "LoadLibraryA"));
; 136  :     return 0;

	xor	eax, eax

; 137  : }

	add	rsp, 168				; 000000a8H
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odsp
; File C:\hub\shellcode\os\win\getapi\extern\extern_llagpa.c
_TEXT	SEGMENT
rva$ = 0
oft$ = 8
ft$ = 16
name$ = 24
ibn$ = 32
api_adr$ = 40
imp$ = 64
base$ = 72
api$ = 80
get_imp	PROC

; 36   : {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 37   :     PDWORD                   name;
; 38   :     LPVOID                   api_adr;
; 39   :     PIMAGE_THUNK_DATA        oft, ft;
; 40   :     PIMAGE_IMPORT_BY_NAME    ibn;
; 41   :     DWORD                    rva;
; 42   :     
; 43   :     rva   = imp->OriginalFirstThunk;

	mov	rax, QWORD PTR imp$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR rva$[rsp], eax

; 44   :     oft   = (PIMAGE_THUNK_DATA)RVA2VA(ULONG_PTR, base, rva);

	mov	eax, DWORD PTR rva$[rsp]
	mov	rcx, QWORD PTR base$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR oft$[rsp], rax

; 45   :     
; 46   :     rva   = imp->FirstThunk;

	mov	rax, QWORD PTR imp$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR rva$[rsp], eax

; 47   :     ft    = (PIMAGE_THUNK_DATA)RVA2VA(ULONG_PTR, base, rva);

	mov	eax, DWORD PTR rva$[rsp]
	mov	rcx, QWORD PTR base$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ft$[rsp], rax

; 48   :       
; 49   :     for (;; oft++, ft++) {

	jmp	SHORT $LN4@get_imp
$LN2@get_imp:
	mov	rax, QWORD PTR oft$[rsp]
	add	rax, 8
	mov	QWORD PTR oft$[rsp], rax
	mov	rax, QWORD PTR ft$[rsp]
	add	rax, 8
	mov	QWORD PTR ft$[rsp], rax
$LN4@get_imp:

; 50   :       // no API left?
; 51   :       if (oft->u1.AddressOfData==0) break;

	mov	rax, QWORD PTR oft$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@get_imp
	jmp	$LN3@get_imp
$LN5@get_imp:

; 52   :       // skip ordinals
; 53   :       if (IMAGE_SNAP_BY_ORDINAL(oft->u1.Ordinal)) continue;

	mov	rax, QWORD PTR oft$[rsp]
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	test	rax, rax
	je	SHORT $LN6@get_imp
	jmp	SHORT $LN2@get_imp
$LN6@get_imp:

; 54   :       
; 55   :       rva  = oft->u1.AddressOfData;

	mov	rax, QWORD PTR oft$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR rva$[rsp], eax

; 56   :       ibn  = (PIMAGE_IMPORT_BY_NAME)RVA2VA(ULONG_PTR, base, rva);

	mov	eax, DWORD PTR rva$[rsp]
	mov	rcx, QWORD PTR base$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ibn$[rsp], rax

; 57   :       name = (PDWORD)ibn->Name;

	mov	rax, QWORD PTR ibn$[rsp]
	add	rax, 2
	mov	QWORD PTR name$[rsp], rax

; 58   :       
; 59   :       // have we a match?
; 60   :       if (name[0] == api[0] && name[2] == api[2]) {

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR name$[rsp]
	mov	r8, QWORD PTR api$[rsp]
	mov	ecx, DWORD PTR [r8+rcx]
	cmp	DWORD PTR [rdx+rax], ecx
	jne	SHORT $LN7@get_imp
	mov	eax, 4
	imul	rax, rax, 2
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR name$[rsp]
	mov	r8, QWORD PTR api$[rsp]
	mov	ecx, DWORD PTR [r8+rcx]
	cmp	DWORD PTR [rdx+rax], ecx
	jne	SHORT $LN7@get_imp

; 61   :         api_adr = (LPVOID)ft->u1.Function;

	mov	rax, QWORD PTR ft$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR api_adr$[rsp], rax

; 62   :         break;

	jmp	SHORT $LN3@get_imp
$LN7@get_imp:

; 63   :       }
; 64   :     }

	jmp	$LN2@get_imp
$LN3@get_imp:

; 65   :     return api_adr;  

	mov	rax, QWORD PTR api_adr$[rsp]

; 66   : }

	add	rsp, 56					; 00000038H
	ret	0
get_imp	ENDP
_TEXT	ENDS
; Function compile flags: /Odsp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\um\winnt.h
;	COMDAT NtCurrentTeb
_TEXT	SEGMENT
NtCurrentTeb PROC					; COMDAT

; 22632:     return (struct _TEB *)__readgsqword(FIELD_OFFSET(NT_TIB, Self));

	mov	rax, QWORD PTR gs:48

; 22633: }

	ret	0
NtCurrentTeb ENDP
_TEXT	ENDS
END
