<META HTTP-EQUIV="expires" CONTENT="0">
<html>
<A name = "top"></A>
<title> CS255 Syllabus </title>
<body
text = "#000000"
link="#00ff00"
vlink="#f00000"
bgcolor="#ffffff"
>

<H3>
<HR>
Recursive Algorithm to Insert at Tail of a Linked List...
<HR>
</H3>
<UL>
<P>
<LI> Suppose you have a linked list at "head":
<P>
 <PRE>
   head
    +--------+     +--------+    -->+--------+    -->+--------+
    |        |---->| info1  |   /   | info2  |   /   | info3  |
    +--------+     |        |  /    |        |  /    |        |
                   +--------+ /     +--------+ /     +--------+
                   | ref1   |-      | ref2   |-      | null   |
                   +--------+       +--------+       +--------+
 </PRE>
 <P>
 And you have a linked list <B>element</B> at "elem":
<P>
 <PRE>
   elem
    +--------+     +--------+
    |        |---->| infoX  | (information has been filled in)
    +--------+     |        |
                   +--------+
                   | ????   | (don't care, because we know there
                   +--------+  is no "next" element)
 </PRE>

<P>
<LI> Here is an example of how the linked list is stored in memory:
 <PRE>
 Memory:
        +---------------+
  <B>head:</B> |  8000         |-------------------------------+
        +---------------+                               |
        |               |                               |
	  .......                                       |
	  .......                                       |
        +---------------+                               |
  8000  |  info1        |  Linked list element 1  <-----+
        +---------------+
        | ref1=10000    |-------------------------------------+
        +---------------+                                     |
        |               |                                     |
        +---------------+                                     |
	  .......                                             |
	  .......                                             |
        +---------------+                                     |
  9000  |  info3        |  Linked list element 3 <----+       |
        +---------------+                             |       |
        | ref3=<FONT COLOR="blue"><B>0 (null)</B></FONT> |                             |       |
        +---------------+                             |       |
	  .......                                     |       |
	  .......                                     |       |
        +---------------+                             |       |
 10000  |  info2        |  Linked list element 2      | <-----+
        +---------------+                             |
        | ref2=9000     |-----------------------------+
        +---------------+
	  .......
	  .......
        +---------------+
  <B>elem:</B> |  20000        |-----------------------------+
        +---------------+                             |
	  .......                                     |
	  .......                                     |
        +---------------+                             |
 20000  |  infoX        | New linked list element <---+
        +---------------+
        | refX=????     |
        +---------------+
 </PRE>
 <P>
 <UL>
 <LI> Notice that the "links" are memory addresses and
	the linked list can be found by tracing/following the 
	addresses in the "linkage" field
 </UL>


<P>
<LI> Inserting the element <B>pointed</B> by "elem" at the <B>tail</B>
     of the linked is realised by making the last element in the linked list
	point to the element <B>pointed</B> by "elem".
  <P>
    This process is illustrated by the following diagram:
 <P>
 Before insertion:
 <PRE>
   head
    +--------+     +--------+    -->+--------+    -->+--------+
    |        |---->| info1  |   /   | info2  |   /   | info3  |
    +--------+     |        |  /    |        |  /    |        |
                   +--------+ /     +--------+ /     +--------+
                   | ref1   |-      | ref2   |-      | null   |
                   +--------+       +--------+       +--------+
   elem
    +--------+     +--------+
    |        |---->| infoX  | 
    +--------+     |        |
                   +--------+
                   | ????   | 
                   +--------+ 
 </PRE>
 After insertion:
 <PRE>
   head
    +--------+     +--------+    -->+--------+    -->+--------+
    |        |---->| info1  |   /   | info2  |   /   | info3  |
    +--------+     |        |  /    |        |  /    |        |
                   +--------+ /     +--------+ /     +--------+
                   | ref1   |-      | ref2   |-      | ref3   |--+
                   +--------+       +--------+       +--------+  |
   elem                                                          |
    +--------+     +--------+                                    |
    |        |---->| infoX  |<-----------------------------------+
    +--------+     |        |
                   +--------+
                   | null   | 
                   +--------+ 
 </PRE>



<P>
<LI> Here is an example of actually happens within the computer memory
     when you "link" a new element to the list:

 <PRE>
 Memory:
        +---------------+
  <B>head:</B> |  8000         |-------------------------------+
        +---------------+                               |
        |               |                               |
	  .......                                       |
	  .......                                       |
        +---------------+                               |
  8000  |  info1        |  Linked list element 1  <-----+
        +---------------+
        | ref1=10000    |-------------------------------------+
        +---------------+                                     |
        |               |                                     |
        +---------------+                                     |
	  .......                                             |
	  .......                                             |
        +---------------+                                     |
  9000  |  info3        |  Linked list element 3 <----+       |
        +---------------+                             |       |
        | ref3=<FONT COLOR="red"><B>20000</B></FONT>    |-----------------------------|---+   |
        +---------------+                             |   |   |
	  .......                                     |   |   |
	  .......                                     |   |   |
        +---------------+                             |   |   |
 10000  |  info2        |  Linked list element 2      | <-----+
        +---------------+                             |   |
        | ref2=9000     |-----------------------------+   |
        +---------------+                                 |
	  .......                                         |
	  .......                                         |
        +---------------+                                 |
  <B>elem:</B> |  20000        |-----------------------------+   |
        +---------------+                             |   |
	  .......                                     |   |
	  .......                                     |   |
        +---------------+                             |   |
 20000  |  infoX        | New linked list element <---+---+
        +---------------+
        | refX=<FONT COLOR="red"><B>null</B></FONT>     |
        +---------------+
 </PRE>
 <P>
 <UL>
  <LI> Notice the change of the address value in the last element of the
	linked list.
   <P>
	This address (20000) is also the address of the list element
	pointed to by "elem"
  <P>
  <LI> The other change is the linkage value of the new last element.
	It must contain ZERO (null) to indicate the end of the list.
  </UL>

<P>
<HR>
<HR>
<HR>
<HR>
<P>
<P>
<P>
<LI> <FONT COLOR="darkmagenta"><B>
     <I>Recursive</I> function to insert a list element at <I>tail</I>
     </B></FONT>
<P>
<UL>

<P>
<UL>
<LI> Insertion at the tail of a list can be done <B>very easily</B>
     by using a <B>recursive algorithm</B>.
<P>
<LI> The following shows what the recursive algorithm
	must do to insert at the tail of a list:
	<A HREF="http://www.mathcs.emory.edu/~cheung/Courses/170/Syllabus/Lists/insert-at-tail2.html"> click here</A>
<P>
<LI> In summary, to insert "elem" at the tail of the list starting at head,
     the recursive algorithm will:
 <P>
 <UL>
 <LI> If head == null, then we have the "base case" of the recursion.
      (A base case is the situation where we know the answer immediately.) 
  <P>
     In this case, the list is empty and we make "elem" the only element
	of the list.
  <P>
     In this case, the head of the new list is "elem"
 <P>
 <LI> If head != null, then we recurse. (Not a base case)
 <P>
     In this case, we insert "elem" at the tail of a "shorter" list
	that is formed by leaving the first element off the original list.
  <P>
     The new list that is formed by inserting "elem" at the tail of the
	"shorter" list is linked AFTER the first element in the original list.
  <P>
     In this case, the head of the list is unchanged.
 </UL>
<P>
<HR>
<HR>

<P>
<LI> The steps above can be expressed in the following function:
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
 <PRE>
  ListElement Insert(ListElement head, ListElement newelem)                    
  {
     ListElement help;

     if head == null)
       { // Base case
         newelem.next = null;
         return(newelem);    // New elem is the head
       }
      else
       { // Recursion

         help = Insert(head.next, newelem);  
			    // Insert elem in shorter list

         head.next = help;  // Link return list AFTER 
			    // the first elem in orig. list
         return(head);      // head is unchanged
       }
   }
 </PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
<P>
</UL>
<P>
<HR>
<HR>
<HR>
<HR>
<P>
<LI> <FONT COLOR="darkmagenta"><B>
     The Main function
     </B></FONT>
<P>
<UL>
<LI> <B>In Java:</B>
<P>
<UL>
<TABLE bgcolor="yellow" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
    ptr = new ListElement();          // Make a new list element  
                                      // Effect: 
				      //   1. reserve 8 bytes of memory
				      //      to store a List oject
				      //   2. return the address of the
				      //      location of the reserved memory        

    ptr.value = 1234;                 // Assignment some value

    head = Insert(head, ptr);         // Insert into list
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
<HR>
<P>
<LI> <B>In assembler:</B>
<P>
<UL>
<TABLE bgcolor="lightcyan" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>
<FONT color="red">
 **** ptr = new ListElement();</FONT>

    move.l #8, d0                  ; 8 byte used to store a List object
    jsr    malloc                  ; allocate (8 bytes) of memory
    move.l a0, ptr                 ; ptr = address of the allocated memory     
<FONT color="red">
 **** ptr.value = 1234;</FONT>

    move.l #1234, (a0)
<FONT color="red">
 **** head = Insert(head, ptr);</FONT>

    move.l head, -(17)             ; pass head in a0
    move.l ptr, -(a7)              ; pass ptr in a1
    bsr    InsertList              ; call InsertList
    adda.l #8, a7		   ; pop parameters
    move.l d0, head                ; head = return value
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

</UL>


<P>
<HR>
<HR>
<HR>
<HR>
<P>
<LI> <FONT COLOR="darkmagenta"><B>
     <I>Recursive</I> InsertList function in M68000
     </B></FONT>
<P>
<UL>
<LI> <FONT color="red"><B>Recall</B></FONT> the
        <FONT color="blue"><B><I>recursive</I> insert algorithm
	</B></FONT> at <B>tail</B> 
	written in <FONT color="red"><B>Java:</B></font>
<P>
<UL>
<TABLE bgcolor="lightyellow" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE>

   static ListElement Insert(ListElement head, ListElement newelem)       
   { 
       ListElement help;

       if head == null)
       {  // Base case
          newelem.next = null;
          return(newelem);    // New elem is the head
       }
       else
       {  // Recursion

          help = Insert(head.next, newelem);  
			    // Insert elem in shorter list

          head.next = help;  // Link return list AFTER 
			    // the first elem in orig. list
          return(head);      // head is unchanged
       }
   }
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>
<LI> <B>In assembler:</B>
<P>
<UL>
<TABLE bgcolor="lightcyan" BORDER="5">
<TR> <TD>

<FONT color="blue">
<B>
<PRE><FONT color="red">
    InsertList:</FONT><FONT color="darkred">
    *-------------------------------- Prelude
        move.l a6, -(a7)
        move.l a7, a6
        suba.l #4, a7
    *--------------------------------</FONT>
    	move.l 12(a6), d0     d0 = head
    	cmp.l  #0, d0         Test: head == null
    	bne    ElsePart	      Go to "ElsePart" if head != null
  <FONT color="red">  	   
    * ========================= Then part</FONT>
        move.l 8(a6), a0      a0 = newelem
    	move.l #0, 4(a0)      newelem.next = null;
    	move.l 8(a6), d0      return(newelem) [in agreed location d0]
    	<FONT color="darkred">   
    *-------------------------------- Postlude
        move.l a6, a7
        move.l (a7)+, a6
    	rts
    *--------------------------------</FONT>
    	   
    	   
     ElsePart:<FONT color="red">
     * ======================== help = InsertList(head.next, newelem);</FONT>
    	move.l 12(a6), a0     (a0 = head)
        move.l 4(a0), -(a7)   (pass head.next)
        move.l 8(a6), -(a7)   (pass newelem)
        bsr  InsertList       Recursion: InsertList(head.next, newelem);
        adda.l #8, a7         Pop the 2 parameters from the stack
    	   
        move.l d0, -4(a6)     help = result of InsertList(head.next, newelem);
    	<FONT color="red">
     * ======================== head.next = help;</FONT>   
        move.l 12(a6), a0     (a0 = head;)
        move.l -4(a6), 4(a0)  help is in -4(16), so this does: <FONT color="red">head.next = help;</FONT>      
    	 <FONT color="red">
     * ======================== return(head);</FONT>  
    	move.l 12(a6), d0     return(head) [in agreed location <FONT color="red">d0</FONT>]
    	   <FONT color="darkred">
    *-------------------------------- Postlude
        move.l a6, a7
        move.l (a7)+, a6
    	rts</FONT>
</PRE>
</B>
</FONT>

</TD> </TR>
</TABLE>
</UL>
<P>

</UL>
<P>
<LI> Program in Java with <B>recursive algorithm</B> to link at tail of list:
     <A HREF="../demo/Linklist2r.java"> click here </A>
<P>
<LI> Program in M68000 assembler with <B>recursive algorithm</B> to link 
	at tail of list:
     <A HREF="../demo/list2r.s"> click here </A>
  <P>
  <B>NOTE:</B> when you read the assembler program:
  <UL>
  <LI> the assembler program uses the function <B>malloc</B> (memory allocate)
	which is used to <B>reserve</B> a certain amount of
	memory.
  <LI> The function <B>malloc</B> takes one input parameter in D0
  <LI> The function <B>malloc</B> returns the <B>location</B> (address)
	of the start of reserved memory in register A0.
  <LI> The function <B>malloc</B> would be equivalent to the
	<B>new</B> operation in Java
  </UL>
</UL>
<HR>
<HR>
